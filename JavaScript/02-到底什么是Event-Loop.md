---
typora-copy-images-to: img\02
---

# 到底什么是Event Loop呢？

## ★资料

**➹：**[Philip Roberts: What the heck is the event loop anyway? - JSConf EU - YouTube](https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=285s)

## ★概述

JavaScript实际上是怎样运作的？

我们都知道V8是Chrome里的JavaScript运行环境，但是它是什么呢？以及它做了什么呢？

我们都知道说到JavaScript，就想到了单线程，但是很明显我们在用回调函数啊！那么回调函数又是怎么运作的呢？

既然如此，JavaScript到底是什么？——嗯，类似这样的：JavaScript是一个单线程、非阻塞、异步、解释性脚本语言，而且它还有一个调用栈、事件循环、回调队列和一些其它的API……总之它们都是一些名词，而且是一些专业名词！

相较于其它浏览器的运行环境，V8是否有特别之处呢？

所以我想问问V8「你是否有调用栈、事件循环、回调队列和其他API？」，于是，V8回答说「我有一个call stack和一个heap，至于其它的？什么鬼？完全不知道哈！」

言归正传，以下内容将为你讲述「为啥JavaScript如此怪异？」，毕竟你在学习JavaScript的过程中，所遇怪异之问题，可谓之如滔滔江水，绵绵不绝……如当你与其它语言比较的时候，你会发现回调明明是个灾难，但还是被引入了。不管怎样，我希望你能够对JavaScript的运行环境有了一些新的见解，为此你能够对这些「怪异」问题考虑得更周全一些……而不是觉得它们就是很「怪异」，没有道理可言！

## ★V8-JS的运行环境

关于JavaScript的运行环境，比如V8，V8是Chrome里的JavaScript运行环境。

下面这个是一个JavaScript的运行环境（Runtime）示意图：

![1546403289278](img/02/1546403289278.png)

解释一下：

- heap记录了内存的分配，想想C语言就知道这个所谓的内存分配了…
- call stack记录了函数调用的执行上下文！总之这是栈帧这类东西所在的地方

此刻或许你会疑问「就这么两个东东吗？」

当然，你可以克隆了V8的代码，然后看看这里面到底有什么东西，你通过搜索  `setTimeout`或者 `DOM`、HTTP请求这些东西的时候，你会发现它们并不在里面！

它们不存在于V8引擎，显然，这会让人大吃一惊，毕竟当你想要异步编程的时候，这些是你首先考虑要使用的东西……可是它们并不存在于V8的源码里面啊！嗯，这很有趣！

作者经过18个月的探索，他开始意识到这是极其重要的部分！而理解「这些部分是什么」显然对你理解JS之所以怪异有很大的助力！

## ★V8之外的一些东西

![1546408455813](img/02/1546408455813.png)

从这张图中我们可以看到：

首先是V8运行环境，然后是浏览器提供的其他东西（被称之为web APIs，DOM、AJAX、setTimeout之类的东西），再然后是神秘的事件循环和回调队列。

想必大家事先都听说过这些术语了吧！但是你们未必能理解这些部分是怎么结合在一起的。

### ◇解释这些术语

#### Call Stack

JavaScript是一个单线程的编程语言。单线程的运行环境意味着它有且只有一个调用栈，它每次只能够做一件事，所以单线程的意思就是「程序每次只可以运行一段代码」。**✎：**

![1546409091794](img/02/1546409091794.png)

对上面所说的内容可视化一下：

![1546410014915](img/02/1546410014915.png)

解释一波：

有一些像左边这样的代码，有一些函数，如一个将两个数字相乘的函数multiply、一个调用了前者的平方函数square、一个打印函数printSquare，它调用了square，然后将结果用console.log打印出来。（函数之间的嵌套调用习以为常……），然后在最后我们调用了printSquare。

这些代码看起来没啥问题，那么我们就来运行它！

Call Stack基本上是一个记录当前程序所在位置的数据结构，如果当前进入了某个函数，那么这个函数就会被放在栈里面。如果当前离开了某个函数，那么这个函数就会被弹出栈外，这就是栈所做的事啦！

如果你运行这个文件，那么将会有一个类似main的函数，它指代文件自身，我们首先把它放进栈，然后，我们从上而下查看声明了的函数，最后是printSquare，我们知道printSquare被调用了，那么我们把它推进栈里。然后它调用了square，所以也把它推进栈里。而square也调用了multiply，同样也把它推进栈。最后我们得到了multiply的返回值。

接着我们把multiply弹出栈，然后square也得到了返回值，再把square弹出栈，最后到printSquare，它调用了console.log，到这里已经没有返回值了。接着我们到了函数的最后部分，然后我们完成了，即call Stack里空空如也！**✎：**

![1546414101142](img/02/1546414101142.png)



这就是一个可视化的调用栈过程啦！如果你以前没有了解过Call Stack，那么现在你就知道了。

当我们在浏览器端做网站开发的时候，如果在Chrome运行下面左边这样的代码，即baz函数调用了bar函数，bar函数调用了foo函数，而foo函数抛出一个错误，那么我们看到会是这样的结果：它将整个栈树都打印了出来，错误从foo开始，到bar， 到baz，到匿名函数（也就是我们说的main函数）。

![1546414246162](img/02/1546414246162.png)

同样地，如果你听说过像内存泄露这类名词，下面的代码就是其中一个例子：

![1546414625026](img/02/1546414625026.png)

我们有一个调用自身的函数foo，然后调用这个foo函数，你猜会发生什么？

我们有一个函数调用了foo，foo又调用了foo，如此一直下去……最后Chrome会说，“你可能并不是想要调用它自己16,000次”、“我为你终止了它，这样你可以找到bug在哪里。”

> 超出最大调用栈大小……

以上就是作者向我们所呈现的一个调用栈了，可能你在开发的时候就已经注意到了……

#### blocking

什么使程序运行变慢？这是一个很难的问题，当然我们借此就来谈谈阻塞！

> 没有严格的定义说什么是阻塞，什么不阻塞。仅仅是指代码运行得很慢，比如说，console.log不慢，遍历从1到10亿很慢，网络请求很慢，下载图片也很慢。反正在栈里表现很慢的东西都叫阻塞……

这里有一个小例子，比如说我们有这样一些伪码（就像jQuery的AJAX请求，如果这些是同步的，会发生什么？，关于请求，请忘记我们对异步的了解，总之虽然它们是在发请求，但调用这些函数是同步的，即这一步结束了，才走下一步，可视化到call stack的话，就是运行一个函数，就在调用栈中记录一次，运行结束后，就弹出栈！不会像之前的嵌套函数调用那样，一直在叠罗汉！），**✎：**

![1546415774139](img/02/1546415774139.png)

如果我们运行这些伪码，那么首先调用了getSync，然后我们在等待.. 因为我们在做网络请求，网络请求相对于计算机本地来说很慢，那么等请求完成了，我们才继续。然后是继续等，再继续……其实我想说的是「这些请求可能永远也不会结束，身为开发者，或许等待没什么，可是用户就不买账了……」，接下来就是请求结束了，接着就运行下面的，当这些所有都跑一遍，栈才会被清空……

如果一个编程语言是单线程的，比如ruby，刚才的状况就会发生。

我们来请求一个资源，我们就要干巴巴地等着请求完成，我们并没有办法可以让我们不需要等待，所以这会有很大的问题——这个问题就是我们的代码是要跑在浏览器上的……

































## ★总结

## ★Q&A

### ①console.log的返回值问题

![1546411650485](img/02/1546411650485.png)

 `<·` 标志，说明最后一个 `undefined` 是浏览器为了标识函数的返回值，**自动加上以供使用者识别**，可以不管！！！

控制台只会显示函数最终的返回值，那些在函数肚子里的嵌套调用所返回的值，都见鬼去吧！

**➹：**[关于console.log()默认返回的undefined - 自由交流 - JSCode](https://jscode.me/t/console-log-undefined/2109)

补充：

![1546412089622](img/02/1546412089622.png)

### ②单线程和多线程？

简单理解单线程就是一次只做一个任务，多线程同时做多个任务！

#### （1）进程与线程有何区别

> 有人在[StackOverflow](https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread)概括得比较全面，线程其实就是轻量级的进程。一般进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程之间能够互相访问资源并进行协调工作，则需要通过进程间的通信。而线程则采用共享内存空间的形式，多个线程可以共享同一份内存空间。相比起进程，虽然线程看起来占用内存空间少了，但是却会出现资源竞争的情况。

#### （2）并行与并发

> 采用多线程或者多进程的方式进行开发的方式称为并发，有些语言甚至可以充分利用电脑CPU的多核特征实现并行。那么并行与并发又有何区别？这里有比较有意思的解答[Github](https://github.com/forhappy/Cplusplus-Concurrency-In-Practice/blob/master/zh/chapter1-Introduction/1.1%20What%20is%20concurrency.md)。
>
> 简单来讲，并行就是多个任务同时执行，而并发则是同一时间段多个任务交替执行。**并行强调的是同一时间点两个任务同时执行，而并发强调的是同一时间段两个任务同时执行。**

**➹：**[多线程有什么用？ - 知乎](https://www.zhihu.com/question/19901763)











