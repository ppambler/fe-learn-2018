---
typora-copy-images-to: img\03
---

# I never understood JavaScript closures

直到有人向我这样解释

原文：[I never understood JavaScript closures – DailyJS – Medium](https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8)

正如标题所述，JavaScript闭包对我来说一直是个谜。我已经[阅读了](https://medium.freecodecamp.org/lets-learn-javascript-closures-66feb44f6a44) [好几篇](https://medium.freecodecamp.org/whats-a-javascript-closure-in-plain-english-please-6a1fc1d2ff1c) [文章](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29) 了，我在工作中使用了闭包，有时我甚至使用了闭包，但却没有意识到我正在使用闭包。

最近我去参加了一个讲座，有人以一种能让我终于明白的方式对它进行了真正的解释。在这篇文章中，我将尝试用这种方法来解释这所谓的闭包。让我把这个功劳归于[CodeSmith](https://www.codesmith.io/)和他们的JavaScript the Hard Parts系列

## ★在我们开始之前

在你开始去理解闭包之前，有一些极其重要的概念得要你事先知晓的，比如执行上下文（ *execution context*）等等

[这篇文章](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/)对执行上下文有一个很好的入门，因此，你可以去看看。我引用了这篇文章的一些内容：

> 当代码在JavaScript中运行时，执行它的环境是非常重要的，而这其中的环境被JavaScript引擎评估为以下之一:
>
> - 全局代码 - 首次执行代码的默认环境
> - 函数代码 - 每当执行流程进入函数体时。
>
> ……
>
> 关于术语`execution context`，我们可以视它为当前代码所被评估的环境/作用域（ *environment / scope*）。

换句话说，当我们启动程序时，我们是从全局的执行上下文开始的。一些变量在全局执行上下文中声明。我们就把这些变量称之为全局变量。当程序中，有调用函数时，会发生什么呢？——有以下几个步骤：

1. JavaScript创建一个新的执行上下文，即，一个局部执行上下文，其实你可以认为这就是一个局部作用域哈！
2. 该局部执行上下文将具有其自己的变量集，而这些变量将会是该执行上下文的局部变量。
3. 这新的执行上下文被抛到执行堆栈（call stack）上 。你可以将执行堆栈视为用来**跟踪程序在执行中的位置**的这样一种机制

那么被调用的函数什么时候就执行结束了呢？当遇到`return`语句或遇到结束括号`}` 时，就GG了。函数结束时，会发生以下情况：

1. 局部执行上下文会从执行堆栈中弹出
2. 这个函数将其返回值发送回调用上下文。调用上下文是调用此函数的执行上下文，它可以是全局执行上下文或另一个局部执行上下文。由调用执行上下文来处理该点的返回值。返回的值可以是一个对象，一个数组，一个函数，一个布尔值等等其它任何东西。如果函数没有`return`语句，则返回`undefined` 。
3. 局部执行上下文被**销毁**。这个很重要。再次强调「销毁（Destroyed）」。意味着在局部执行上下文中声明的所有变量都将被删除。它们不再可用。这就是它们被称为**局部变量**的原因啦！

## ★一个非常基础的例子

在我们开始讲解闭包之前，让我们先来看一下下面这段代码。它看起来非常简单，任何读这篇文章的人都可能确切地知道它的作用。

```
1: let a = 3
2: function addTwo(x) {
3:   let ret = x + 2
4:   return ret
5: }
6: let b = addTwo(a)
7: console.log(b)
```

为了理解JavaScript引擎是如何工作的，所以我们来仔细地分析一下它，看看这段代码到底有什么名堂

1. 在第1行，我们在全局执行上下文中声明了一个新变量a ，并为其分配（assign）了一个数值`3` 。
2. 接下来就有点棘手了。第2行到第5行是一个整体。那么这里发生了什么呢？我们在全局执行上下文中声明了一个名为`addTwo`的新变量。然后我们分配（assign）给它的是什么呢？一个函数定义。两个括号`{ }`之间的任何内容都分配给了`addTwo` 了。函数内部的代码不会被评估，也不会执行，只是存储在变量中以备将来使用。
3. 那么现在我们来到第6行代码了。它看起来很简单，但是这里有很多东西需要拆开来看。首先，我们在全局执行上下文中声明了一个新变量，并将其标记为`b` 。声明变量后，它的值就默认初始为`undefined` 啦。
4. 接下来，仍然还是在第6行，我们看到了一个赋值运算符。我们正准备给变量`b`分配一个新值。接下来我们看到一个被调用的函数。当你看到一个变量后跟圆括号`(…)` ，那么这就是调用函数的信号啦！暂且快进一下（[Flash forward](https://zh.wikipedia.org/wiki/%E6%9C%AA%E6%9D%A5%E9%97%AA%E5%BD%B1)），即假设我们已经拿到了函数调用的结果。每个函数都会返回一些东西（如值，对象或`undefined` ）。而从函数返回的任何内容都将分配给变量`b` 。
5. 然而首先我们需要调用标记为`addTwo`的函数。JavaScript（默认指JavaScript引擎）将在其全局执行上下文内存中查找名为`addTwo`的变量。哦，它找到了一个，它是在步骤2（或第2-5行）中定义的。 然后就瞧见（lo）变量`addTwo`包含一个函数定义。请注意，变量`a`作为参数传递给了这个函数。JavaScript在其全局执行上下文内存中搜索到了变量`a` ，找到它之后，发现它的值为`3`，接着就将数值`3`作为参数传递给函数。准备执行该函数啦！
6. 现在执行上下文将会切换。创建一个新的局部执行上下文，我们将其命名为“addTwo执行上下文”。而这执行上下文将会被推送到调用堆栈里边（call stack）。那么我们在局部执行上下文中做的第一件事是什么呢？
7. 您可能会想说，“在局部执行上下文中声明了一个新的变量`ret` ”。不过，这不是答案。正确答案是，我们首先需要查看函数的参数。在局部执行上下文中声明了一个新变量`x` 。接着，由于值3作为参数传递给了形参x，因此局部变量x被赋值为`3` 。
8. 下一步是：在局部执行上下文中声明新的变量`ret` 。其值被设置为undefined。（第3行）
9. 仍然是第3行，接着需要执行一个加法。首先，我们需要拿到x的值。为此，JavaScript将会查找变量`x` 。它将首先查看局部执行上下文。它找到了一个，值是`3`。第二个操作数是`2` 。加法（ `5` ）的结果被赋予变量`ret` 。
10. 第4行。我们返回变量`ret`的内容。同样，我们也要在局部执行上下文里边查找ret变量。查找得知，`ret`包含`5`这个值。所以该函数返回的是数值`5`。至此，函数就结束了。
11. 第4-5行。这函数就结束了。该局部执行上下文也就意味着就被销毁了。 局部变量`x`和`ret`被消灭了。它们已经不存在了。其上下文已经被弹出调用堆栈了，返回值则返回到调用函数的那个上下文里边。对于我们这个例子的这种情况，调用上下文就是全局执行上下文，毕竟函数`addTwo`是从全局执行上下文中调用的。
12. 现在，我们从第4步中断的地方开始。返回值(数值`5` )被赋给变量`b`。我们仍然在这个小程序的第6行。
13. 我不打算详细介绍log函数是个什么执行情况了，但是在第7行里边，变量`b`的内容将在控制台中打印出来。而在我们的这个例子里边是`5`。

对于一个非常简单的程序来说，这是一个非常冗长的解释，我们甚至还没有触及闭包。当然，我保证我们会实现这篇文章的目标。不过，首先我们还需要再走一两条弯路先。

## ★词法作用域（Lexical scope）

 我们需要理解词法作用域的某些方面。请看下面的例子。

```
1: let val1 = 2
2: function multiplyThis(n) {
3:   let ret = n * val1
4:   return ret
5: }
6: let multiplied = multiplyThis(6)
7: console.log('example of scope:', multiplied)
```

这里的想法是我们在局部执行上下文中有变量，而在全局执行上下文中同样也有变量。 JavaScript的一个复杂之处在于它**如何查找变量**。 如果它在局部执行上下文中找不到变量，那么它将在其调用上下文中查找它（变量）。 如果没有在其调用上下文中找到它（变量），那么反复地，直到它（JavaScript引擎）查看全局执行上下文。 （如果JavaScript引擎没有找到它，那么它就是`undefined`的）。 根据上面的例子，而该例子将会弄清楚这件事。 如果您了解作用域的工作原理，则可以跳过此步骤。  

> 我了解了，但我不打算跳过！

1. 在全局执行上下文中声明一个新变量`val1` ，并为其分配数字`2` 。
2. 2到5行，声明一个新变量`multiplyThis`并为其赋值一个函数定义，就是一个函数啦！
3. 第6行。在全局执行上下文中声明一个叫`multiplied`的新变量。
4. 从全局执行上下文内存中检索变量`multiplyThis`并将其作为函数执行。传递数字`6`作为该函数的参数，也就是作为形参的实参啦！
5. **新函数调用=新执行上下文**。创建一个新的局部执行上下文。
6. 在局部执行上下文里边，声明一个变量`n`并为其分配数字`6`。
7. 第3行。在局部执行上下文里边，声明一个变量`ret` 。
8. 第3行（续）。 用两个操作数执行乘法运算; 那么变量`n`和`val1`的内容是什么呢？ 在局部执行上下文中查找变量`n`。 我们知道在第6步中声明了它。它的内容是数字`6`。 在局部执行上下文中查找变量`val1`。 然而局部执行上下文里边并没有标记为`val1`的变量。 因此，让我们来检查调用上下文。 而调用上下文是全局执行上下文。 至此，让我们在全局执行上下文中查找`val1`。 哦，是的，它就在那里。 它在步骤1里边被定义了。而且它的值为数字`2`。
9.  第3行（续）。 将两个操作数相乘并将其分配给`ret`变量。 `6 * 2 = 12`. `ret`现在是`12`了！而不是原先的`undefined`了！
10. 返回ret变量。局部执行上下文连同变量`ret`和`n`一起被销毁了，换句话说，从call stack中弹出去了。当然，变量`val1`没有被销毁，因为它是全局执行上下文的一部分哈！
11. 返回第6行。在调用上下文中，将数字`12`分配给`multiplied`变量。
12. 最后，在第7行，我们在控制台中显示`multiplied`变量的值。

所以在这个例子中，我们需要记住的是**一个函数是可以访问在其调用上下文中所定义的变量的**。而这种现象的正式名称是**词法作用域**。

## ★A function that returns a function（一个返回函数的函数）







